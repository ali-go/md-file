日常一些优秀的代码、优化等知识的收集和汇总

#### 1、防抖函数

短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。

```js
function debounce(fn, delay = 500) {
	//timer是闭包里面的 重点重点
	let timer = null;
	return function () {
		if (timer) clearTimeout(timer);
		timer = setTimeout(function () {
			fn.apply(this, arguments);
		}, delay);
	};
}
//1秒内页面多次点击只执行最后一次
document.addEventListener('click', debance(() => {
    console.log('hahah');
}, 1000))
```

#### 2、节流函数

```js
//节流的作用例如在拖拽获取坐标
function throttle(fn, delay = 100) {
	//设置一个闭包里面的定时器
	let timer = null;
	return function () {
		if (timer) return;
		timer = setTimeout(() => {
			fn.call(this, arguments);
			timer = null;
		}, delay);
	};
}
 document.addEventListener('click', throttle(() => {
    console.log('hahah');
}, 1000))
```

#### 3、数组去重

（1）、用`hasOwnProperty`实现数组去重的方法：

`hasOwnProperty`用于判定某个对象中是否有某个属性：

```js
var o = { a: 1};
console.log(o.hasOwnProperty('a')); // true
console.log(o.hasOwnProperty('b')); // false
```

分析：本质是创建temp中间对象,unique中间数组，遍历原数组的每一项元素，获取元素的值，再查询对应的中间对象temp中是否有该属性，如果没有加添加进去，同时该元素值追加到中间数组中。

```js
var arr = ['a', 'b', 'c', 'b'];

function uniqueArr(arr){

    var unique = [], temp = {};

    for(var i = 0; i < arr.length; i++){
        if(temp[arr[i]] === undefined){
            temp[arr[i]] = 1;
            unique.push(arr[i]);
        }
    }

    return unique;
}
console.log(uniqueArr(arr));// ["a", "b", "c", "d"]
```

(2)、利用indexof()

indexof方法查询是否有该元素，如果没有，则返回-1，有则返回相应的索引号。

```js
let arr = ['a', 'b', 'c', 'd', 'a', 'b']
let newArr = []

function getOnly(arr) {
		for (let i = 0; i < arr.length; i++) {
				if (newArr.indexOf(arr[i]) == '-1') {
						newArr.push(arr[i])
				}
		}
		return newArr
}
console.log(getOnly(arr));// ["a", "b", "c", "d"]
```

(3)、利用set数据类型

```js
let arr = ['a', 'b', 'c', 'd', 'a', 'b']
let newArr = new Set(arr)
console.log(newArr);// ["a", "b", "c", "d"]
```

#### 4、深拷贝

```js
function deepClone(obj = {}) {
		let res
		if (typeof obj !== "object" || obj === null) {
				// 如果不是对象或数组直接返回
				return obj;
		}
		if (obj instanceof Array) {
				// 如果为数组
				res = [];
		} else {
				res = {};
		}

		for (key in obj) {
				// 判断是否是obj的key
				if (obj.hasOwnProperty(key)) {
						res[key] = deepClone(obj[key]);//递归
				}
		}
		return res;
}

obj1 = {
				a: 1,
				b: 2,
				c: 3
		}
		// console.log(obj1.hasOwnProperty('a'));
let obj2 = deepClone(obj1)
console.log(obj1);//{a: 1, b: 2, c: 3}
console.log(obj2);//{a: 1, b: 2, c: 3}
obj1.d = 4
console.log(obj1);//{a: 1, b: 2, c: 3, d: 4}
console.log(obj2);//{a: 1, b: 2, c: 3}
```

#### 5、proxy反向代理（解决跨域，配置多个代理）

请参考地址：https://blog.csdn.net/marendu/article/details/103733286

配置多个代理
只需让你本地请求，满足代理的规则即可

```js
proxy:{
  "/api": {										//api是需要转发的请求
      target: "http://www.xiongmaoyouxuan.com", //配置转发目标地址(能返回数据的服务器地址)
      // ws: true, 
      changeOrigin: true 						//控制服务器接收到的请求头中host字段的值
      pathRewrite: {
          "^/api": "/api"						//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)
      }
  },
  "/user": {
      target: "http://www.xiongmaoyouxuan.com",
      // ws: true, 
      changeOrigin: true
      pathRewrite: {
          "^/user": "/api"
      }
  },
```


在创建axios的时候，beseURL这样配置

```js
const ajax = axios.create({
    baseURL:"/",
    timeout: 6000,//请求超时时间
})
```


创建的请求

```js
export function getData() { //get
  return request({
    url: 'api/search/home',
    method: 'GET'
  })
}
export function getData1() { //get
  return request({
    url: 'user/search/home',
    method: 'GET'
  })
}
```

原文链接：https://blog.csdn.net/marendu/article/details/103733286

实际操作补充：

当有多个跨域存在时：

代理处：

```js
proxy:{
  "/api": {
      target: "http://www.xiongmaoyouxuan.com/api", 
      // ws: true, 
      changeOrigin: true
      pathRewrite: {
          "^/api": ""
      }
  },
   "/user": {
      target: "http://www.baidu.com/user",
      // ws: true, 
      changeOrigin: true
      pathRewrite: {
          "^/user": ""
      }
  },
```

利用一个公共方法对/api和/user和后续路径拼接，此处略。

#### 6、路由的元信息meta

使用到beforeEach 钩子函数进行验证操作,to.matched会得到所有的路由，数组形式，通过循环matched这个数组，some()方法筛选验证。

meta字段（元数据）
直接在路由配置的时候，给每个路由添加一个自定义的meta对象，在meta对象中可以设置一些状态，来进行一些操作。用它来做登录校验再合适不过了

```js
{
  path: '/actile',
  name: 'Actile',
  component: Actile,
  meta: {
    login_require: false
  },
},
{
  path: '/goodslist',
  name: 'goodslist',
  component: Goodslist,
  meta: {
    login_require: true
  },
  children:[
    {
      path: 'online',
      component: GoodslistOnline
    }
  ]
}
```

这里我们只需要判断item下面的meta对象中的login_require是不是true，就可以做一些限制了

```js
router.beforeEach((to, from, next) => {
  if (to.matched.some(function (item) {
    return item.meta.login_require
  })) {
    next('/login')
  } else 
    next()
})
```


原文链接：https://blog.csdn.net/cofecode/article/details/79181894

#### 7、利用scrollIntoView()进行tab栏切换滚动

语法：

```js
element.scrollIntoView（）; // 等同于element.scrollIntoView(true)
element.scrollIntoView（alignToTop）; //布尔参数
element.scrollIntoView（scrollIntoViewOptions）; //对象参数
```

参数：

（1）、alignToTop	[可选]，目前之前这个参数得到了良好的支持
true：元素的顶部将对齐到可滚动祖先的可见区域的顶部。对应于scrollIntoViewOptions: {block: "start", inline: "nearest"}。这是默认值
false	元素的底部将与可滚动祖先的可见区域的底部对齐。对应于scrollIntoViewOptions: {block: "end", inline: "nearest"}。

（2）、scrollIntoViewOptions	[可选]，目前这个参数浏览器对它的支持并不好，可以查看下文兼容性详情
behavior：[可选]定义过渡动画。"auto","instant"或"smooth"。默认为"auto"。
block：[可选] "start"，"center"，"end"或"nearest"。默认为"center"。
inline：[可选] "start"，"center"，"end"或"nearest"。默认为"nearest"。

用法：

场景模拟：

1、需要切换的tab栏，写在数组里面用，span包裹遍历；

2、实际tab栏，用div包裹，所有div取一个同样的class类名；

3、点击span时获取index；

4、获取所有div的元素，document.getElementsByClassName("类名")；

5、滚动到指定div处，

document.getElementsByClassName("类名").[index].scrollIntoView({behavior:"smooth});

#### 8、关于axios的封装

```js
    // 1、新建xiaos的实例
    const instance = axios.create({
        baseURL: 'http://152.136.185.210:7878/api/m5',
        timeout: 5000
    })

    // 2、请求的拦截
    instance.interceptors.request.use(config => {
        // console.log(config);
        return config
    })
    // 3、响应的拦截
    instance.interceptors.response.use(res => {
        // console.log(res);
        return res.data
    })

    // 4、导出request封装
 export default{
	get:(url,params)=>{
        return instance.get(url,{
			params,
        })
    },
    post:(url,params)=>{
        return instance.post(url,params)
    }
 }

```

使用时直接调用对应的get()或者post(),附加对应的路径和参数进行请求。

#### 9、关于弹框动画（用css缩放写）

此处写关于打开和关闭弹框时的缩放动画。

1、用一个盒子box包住弹框的内容content；

2、给这个content设置一个动态style，用isshow控制这个动画开始和结束的style，默认为false；

3、style写transform:scale(1)和transform:scale(0），true是1，false是0；

4、content内部写样式transition过渡给transform，设置200毫秒（根据需求来）

5、弹框打开时为了有效果，在mounted中200毫秒后把isshow设置为true，即内容content会从0变为1，即从无到有，过渡时间为200毫秒；

6、关闭的时候类似，box弹框可以马上关闭，但是isshow控制content的消息设置200毫秒时间，把isshow改为false，如此就有打开和关闭的动画效果；

#### 10、关于vue.config.js的一些配置

四种配置方式：暂时只写方式，不写具体的配置内容

```js
const path = require("path");
// const ElementPlus = require("unplugin-element-plus/webpack");
const AutoImport = require("unplugin-auto-import/webpack"); //element-plus按需导入
const Components = require("unplugin-vue-components/webpack"); //element-plus按需导入
const { ElementPlusResolver } = require("unplugin-vue-components/resolvers"); //element-plus按需导入
module.exports = {
  // 几种修改配置的方式：
  // 第一种：使用cli特有的属性修改配置
  outputDir: "build",
  // 第二种：使用configureWebpack对象包裹和webpack完全一致的属性配置，最后会使用webpack-merge进行合并的
  configureWebpack: {
    resolve: {
      alias: {
        components: "@/components"
      }
    },
    plugins: [
      // 按需导入element-plus组件的样式表
      require("unplugin-element-plus/webpack")({
        // 引入的样式的类型，可以是css、sass、less等，
        importStyle: "css",
        useSource: true
      }),
      AutoImport({
        resolvers: [ElementPlusResolver()]
      }),
      Components({
        resolvers: [ElementPlusResolver()]
      })
    ]
  }
  // 第三种：使用configureWebpack函数形式，暴露原有配置参数，下面对配置重新覆盖操作
  // configureWebpack: (config) => {
  //   config.resolve.alias = {
  //     "@": path.resolve(__dirname, "src"),
  //     components: "@/components"
  //   };
  // },
  // 第四种：使用chainWebpack函数来链式操作进行修改
  // chainWebpack: (config) => {
  //   config.resolve.alias
  //     .set("@", path.resolve(__dirname, "src"))
  //     .set("components", "@/components");
  // }
};
```

常见的配置信息：

```js
module.export={
    publicPath:"/",//配置应用程序部署的子目录（默认是 `/`，相当于部署在 `https://www.my-app.com/`）；
    outputDir:"dist",//编译打包存放的目录默认dist
    lintOnSave: false,// 如果你不需要使用eslint，把lintOnSave设为false即可
    configureWebpack:{
        //警告webpack的性能提示
        performance:{
            hints:"warning",
            maxEntrypointSize: 2048000, // build时静态文件和入口文件大小设置
            maxAssetSize: 1024000,//生成文件的最大体积
        }
    },
    //本地开发调试配置（不会被打包进去）
    devServer：{
    	disableHostCheck:false,//vue本地服务不能被外部IP访问的解决方法
    	hot:true,//模块热替换机制开启
    	inline：true，//开启inline刷新模式，自动刷新
    	//跨域代理
    	proxy:{
    		"/server":{
    			target:"http://www.ali.com/server",
    			changeOrigin:true,
    			pathRewrite:"",//注意此处重写不写是因为target已经写了，如果上面不写此处要写。
    			//（调用的地址必须再次拼接上这个参数，改了配置必须重启）
			}
		}
	}
    
}
```

#### 11、路由懒加载

懒加载：又叫延时加载，即在需要的时候进行加载，随用即载

使用懒加载的原因：

像vue这种（spy）单页面应用，如果没有使用到懒加载，webpack打包的文件过大，造成进入首页时，加载的资源过多，时间过长，即使做了loading也不利于用户体验，而运用懒加载可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载事件，简单来说就是进入首页不用一次加载过多资源造成时间过长。

 **懒加载的使用方法：**

（1）、ES 提出的import方法：

**最常用**：const HelloWorld = （）=>import('需要加载的模块地址')，

```js
const HelloWorld = () => import("@/components/HelloWorld")

{
      path: '/',
      name: 'HelloWorld',
      component:HelloWorld
},
```

（2）、vue异步组件实现懒加载 :

方法如下：component：resolve=>require(['需要加载的路由的地址']，resolve)

```js
{
      path: '/',
      name: 'HelloWorld',
      component:resolve=>require(['@/components/HelloWorld']，resolve)
},
```

#### 12、一些不常用的css选择器及less选择器

（1）、& 表示当前本身，可以理解为且

（2）、+ 表示下一个兄弟：

（3）、~ 表示兄弟，不限定是下一个

举例：如果有10个div，每个都取名.box，现在想设置除了第一个没有margin-top，其余都要有margin-top，则可以如下设置。

```css
.box{
	& + .box{
		margin-top:10px;
	}
}
//这个css设置会施加到每个.box上，每一个本身的下一个兄弟.box都加外边距，只有第一个.box没有上一个兄弟，因此本身就不会有外边距设置。此方法等同于用先设置所有，再去除第一个。
```

（3）、:not(:nth-child(2)) 表示除去第二个的元素

#### 13、scrollBehavior(to,from,savedPosition) 滚动

官方地址：https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html

使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 `vue-router` 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。

用法示例：

```js
const router = new VueRouter({
    routes,
    scrollBehavior(to, from, savedPosition) {
        // console.log(to, from, savedPosition);
        console.log(to, from);
        if (savedPosition) {
            return savedPosition
        } else if (to.path == "/home") {
            return { x: 0, y: 200 }
        } else {
            return { x: 0, y: 800, behavior: "smooth" }
        }
    }
});
```

scrollBehavior接收三个参数，to的路由，from的路由，以及`savedPosition` 当且仅当 `popstate` 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。

savedPosition是点击浏览器前进后退导航时才触发，本身打印出来是对应的位置{x:...,y:...}，x和y分别是切换前的位置信息。

上述例子中当路由切换时触发scrollBehavior滚动，当点击浏览器导航键时返回对应的原始位置。当跳转到home时，滚动到y为200的地方，注意此时是直接跳转的。其余情况跳转到y为800处，注意加了behavior:"smooth"，表示平滑滚动，带过渡动画。

以上是基础用法，实际可以根据路由的元信息等或者keep-alive等做判断进行回滚。

#### 14、比较两个对象是否完全相同

思路：选出不相同的，剩下的都是相同。

情形一：简单的对象数据，即属性值是简单数据类型。

```js
function commonObject(obj1,obj2){
    let obj1keys = Object.keys(obj1);
    let obj2keys = Object.keys(obj2);
    for (let i = 0; i <= obj1keys.length - 1; i++) {
        let key = obj1keys[i];
        // if(条件) continue		//可以设置一些条件不做判断跳过，如数据的id之类的
        if (!obj2keys.includes(key)) return false; //只要有一个属性名不一致就是不相同
        if (obj2keys.includes(key) && obj1[key] !== obj2[key]) return false; //当属姓名相同但是属性值不同就不相同（只要有一个就可以做判断）
    }
    return true; //上面把不同的情况选出来了，执行到这里就是相同的对象

}

let a = { sex: "男", age: 18 };
let b = { sex: "男", age: 18 };
console.log(this.commonObject(a, b));//true
```

#### 15、关于上传表单转换成formData格式

默认传给后端的格式是application/json的，但是像表格文件上传之类的需要设置成multipart/form-data格式的，因此请求头数据类型就要进行修改，并用formData类型参数，就需要转换。

asiox一共请求方式有get,post,put,put,delete
get,post,put,put有三个参数，url,data和config，所以在使用时，可以写成axios.method (‘url’,data,config),但是delete只有两个参数：url和config，data在config中，所以需要写成 axios.delete(‘url’,{data:{id:1}})。
————————————————
版权声明：本文为CSDN博主「badboy__biubiubiu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/kjssjj12/article/details/106410399

**方式一：**封装的请求可以根据自己的习惯进行，比如直接拿最直接的：

```js
function UploadDoc(data){
    instance({
        url:"",
        method:"",
        ContentType:"multipart/form-data",//此为请求类型
        data:data,
        ...
    })
}
```

上述方法在修改ContentType时可以直接设置，在请求拦截时判断不加这个属性就默认为多少，加了按加的执行即可。

**方式二：**还有是对请求的方法直接封装的，如下（**详情看第8要点**）：

```js
 post:(url,params)=>{
        return instance.post(url,params)
 }
```

此方法对方法进行了封装，但是其实可以传递第三个参数：

```js
 post:(url,params,type)=>{
     //根据参数判断是否设置特殊的请求头
     if(type){
          return instance.post(url,params,{
              headers:{"Content-Type":"multipart/form-data"}//请求数据类型限制
          })
     }else{
          return instance.post(url,params)
     }
       
 }
```

设置完上述的请求数据类型之后，我们就要对传递的数据类型进行转换成formData：

请求的config内有一个方法transformRequest，就是用来转换formData用的，我们可以在方法内部去执行转换的操作；

一般我们都是写在请求拦截里面的，我们可以根据自己传递的自定义的参数去判断哪些请求需要去做类型的转换。

**方式一中请求的过程：**

```js
//封装的方法中
//假定data参数为{file:file.raw}
function UploadDoc(data){
    instance({
        url:"",
        method:"",
        ContentType:"",//此为请求类型
        data:data,
        isUpload:true,//该属性用于确认该请求是否需要转换数据类型
    })
}

//请求拦截中（其余多余代码省略，假定参数为config）
//判断需要转换
if(config.isUpload){
    //执行transformRequest方法，内部会执行,此data为请求传递的参数，并非config
    config.transformRequest = data=>{
        const formData = new FormData();//创建formData对象
        formData.append("file",data.file);//追加进formData对象中
        return formData ;//返回formData对象
        //以上三个步骤就是转换成formData的过程，内部会自动把data参数转换成formData对象类型
    }
    delete config.isUpload //移除用于做判断的自定义属性
}
return config
```

**方式二的请求：**

```js
//调用方法处(此处的request为下方导出post请求的文件)
import request from "request.js"
request.post(url,data,true);//假定data参数为{file:file.raw},第三个参数为true

//封装的方法中
//type为自定义用来标识是否需要改请求类型的，假定type=true
 post:(url,params,type)=>{
     //根据参数判断是否设置特殊的请求头
     if(type){
         params.isUploading = true ;//用于作为需要调整请求参数的数据类型成formData的标识
          return instance.post(url,params,{
              headers:{"Content-Type":"multipart/form-data"}//请求数据类型限制
          })
     }else{
          return instance.post(url,params)
     }
 }
 
 //请求拦截的文件中（其余多余代码省略，假定参数为config）
 //判断是否需要转换数据类型
 if(config.data.isUpload){
     //执行transformRequest方法，内部会执行,此data为请求传递的参数，并非config
     config.transformRequest = data=>{
        const formData = new FormData();//创建formData对象
        formData.append("file",data.file);//追加进formData对象中
        return formData ;//返回formData对象
        //以上三个步骤就是转换成formData的过程，内部会自动把data参数转换成formData对象类型
    }
     delete config.data.isUpload //移除标识
 }
return config
```

以上就是在进行上传表单等文件需要转换请求类型和请求数据参数类型的请求过程。



#### 16、关于element-ui的el-table行和列的拖拽进行排序

案例地址：https://blog.csdn.net/xingbipai5492/article/details/89704781

注意案例中定义了两个一样的数组作为表头遍历，博主是为了演示行和列分别拖拽，实际操作只需要定义一个数组用于遍历表头！

表格拖拽利用sortablejs插件；

利用插件的onEnd函数，接收开始和结束的index索引，然后对索引对应的元素进行替换，行程最终拖拽的效果。

```js
<template>
  <div style="width:800px">
    <el-table :data="tableData"
      border
      row-key="id"
      align="left">
     <el-table-column v-for="(item, index) in dropCol"
        :key="item.prop"
        :prop="item.prop"
        :label="item.label"> 
      </el-table-column>
    </el-table>

	//下面是演示数据变化
    <pre style="text-align: left">
      {{dropCol}}
    </pre>
    <hr>
    <pre style="text-align: left">
      {{tableData}}
    </pre>
  </div>
</template>
<script>
import Sortable from 'sortablejs'
export default {
  data() {
    return {
      dropCol: [
        {
          label: '日期',
          prop: 'date'
        },
        {
          label: '姓名',
          prop: 'name'
        },
        {
          label: '地址',
          prop: 'address'
        }
      ],
      tableData: [
        {
          id: '1',
          date: '2016-05-02',
          name: '王小虎1',
          address: '上海市普陀区金沙江路 100 弄'
        },
        {
          id: '2',
          date: '2016-05-04',
          name: '王小虎2',
          address: '上海市普陀区金沙江路 200 弄'
        },
        {
          id: '3',
          date: '2016-05-01',
          name: '王小虎3',
          address: '上海市普陀区金沙江路 300 弄'
        },
        {
          id: '4',
          date: '2016-05-03',
          name: '王小虎4',
          address: '上海市普陀区金沙江路 400 弄'
        }
      ]
    }
  },
  mounted() {
  // 阻止默认行为
	document.body.ondrop = function (event) {
             event.preventDefault();
             event.stopPropagation();
     };
    this.rowDrop()
    this.columnDrop()
  },
  methods: {
    //行拖拽
    rowDrop() {
        //行拖拽是在tbody内发生的(所有的tr都在tbody内)
      const tbody = document.querySelector('.el-table__body-wrapper tbody')
      const _this = this
      Sortable.create(tbody, {
        onEnd({ newIndex, oldIndex }) {
          const currRow = _this.tableData.splice(oldIndex, 1)[0]//注意splice返回的是被删除元素的数组
          _this.tableData.splice(newIndex, 0, currRow)
        }
      })
    },
    //列拖拽
    columnDrop() {
        //列拖拽是在tr内发生的(所有的表头都在一个tr内)
      const wrapperTr = document.querySelector('.el-table__header-wrapper tr')
      this.sortable = Sortable.create(wrapperTr, {
        animation: 180,
        delay: 0,
        onEnd: { newIndex, oldIndex } => {
          const oldItem = this.dropCol[oldIndex]
          this.dropCol.splice(oldIndex, 1)
          this.dropCol.splice(newIndex, 0, oldItem)
        }
      })
    }
  }
}
</script>

ul内的li拖拽同理
```



#### 17、关于flexible.js + rem 响应式布局

flexible.js这个插件会根据你的需求去将屏幕分成指定的份数，每一份都是1个rem，对应html的font-size的大小；

正常是10份，我们可以改内部的代码根据需求指定分数；

一般还搭配vscode插件**pxtorem**或者也叫**cssrem**，这个插件能帮助我们在输入对应的px尺寸时 下方会提示可选转换对应的rem值，

我们可以根据自己的需求在这个插件设置中指定font-size大小即一个rem的大小。

举个例子：

设计稿为1920的屏幕，当前某个盒子是80px高，我们把屏幕分成24份，那么80px显然就是1rem，此时我们电脑为1280的屏幕，24份也就是53.3px为1rem，那么我们实际在自己电脑中开发就得写53.3px而不是80px，但是我们是根据设计稿的px高度去开发的，显然不可能每个高度都转成自己计算rem值，因此我们可以在cssrem插件中把1rem设置成80px，实际写样式我们依旧按设计稿写80px，系统会识别这个80px为1rem，我们就选择下方这个1rem，最后实际的效果这个1rem是基于我们1280屏幕的，也就是53.3px，这样就避免了我们实际开发手动去计算80px对应当前屏幕下的尺寸，我们依旧按原设计图去开发就行。

#### 18、一些常用的正则限制输入框类型的问题(持续更新)

常见的正则网址：http://c.runoob.com/front-end/854

知识点：^表示以什么开头，$表示以什么结尾，但是当在类型前面直接写^就表示取反。

```js
^\d{n}$			：表示匹配n位的数字；
/[^\d]/g		：表示匹配不为数字的内容

案例1：输入框只能输入整数(包含正负整数和0)
let str;
let first = val.substr(0,1);//先判断第一个是否为负号
if(first==="-"){
    str = val.replace(/[^\d]/g,"");//把所有不为数字的替换为空
    str = "-" + str;//前面补负号
}else{
    str = val.replace(/[^\d]/g,"")
}

案例：只允许输入两位小数
function clearNumber(num){
	num = num.replace(/[^\d.]/g,'');//所有不是数字.结尾的都替换为空
    num = num.replace(/^\./g,'');//上面的值再把所有以.开头的都替换为空
    num = num.replace(/\.{2,}/g,'.');//继续替换，再把所有大一一个的.都替换为一个.
    return num
}
```

#### 19、Vue中自定义指令(持续更新)

```js
案例1：点击元素之外的区域调用事件
//(1)、在js文件中：
import Vue from 'vue'
//自定义指令-点击div区域之外触发

// 提交验证
Vue.directive('clickOutside', {
    // 初始化指令
    bind(el, binding) {
        function clickHandler(e) {
            // 这里判断点击的元素是否是本身，是本身，则返回
            if (el.contains(e.target)) {
                return false;
            }
            // 判断指令中是否绑定了函数
            if (binding.expression) {
                // 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法
                binding.value(e);
            }
        }
        // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听(这个__vueClickOutside__是自定义的变量名)
        el.__vueClickOutside__ = clickHandler;
        document.addEventListener('click', clickHandler);
    },
    update() { },
    unbind(el) {
        // 解除事件监听
        document.removeEventListener('click', el.__vueClickOutside__);
        delete el.__vueClickOutside__;
    },
});

//(2)、在main.js文件中:
//自定义指令引入(全局引入)
import './directive/directive'

//(3)、在引用页面(outsideClick方法内写需要执行的逻辑)
 <div  v-click-outside="outsideClick"></div>
     
     
案例2：权限按钮的自定义指令
//(1)、封装
import Vue from "vue"
Vue.directive("premission",{
    inserted(el,binding){
		const action = binding.value.action;
        if(!action){
            el.parentNode.removeChild(el)
        }
    }
})

//（2）、调用
<el-button v-premission={action:true/false}></el-button>

案例3：vue3全局指令-格式化时间
//(1)、封装
import dayjs from "dayjs";
export default function (app) {
  let format = "YY:MM:DD HH:mm:ss"; //设置默认的时间格式化格式
  app.directive("format-time", {
    created(el, bingings) {
      if (bingings.value) {
        format = bingings.value; //获取用户定义的时间展示格式
      }
    },
    mounted(el) {
      const textContent = el.textContent; //获取当前值
      let timestamp = parseInt(textContent); //转成数值格式
      if (timestamp.length == 10) {
        timestamp = timestamp * 1000; //如果后台给的是秒转换成毫秒
      }
      el.textContent = dayjs(timestamp).format(format); //利用dayjs进行格式转换
    },
  });
}
//(2)、调用
 <span v-format-time:info="'YY:MM:DD HH:mm:ss'">1637910658504</span>
```

#### 20、关于element-ui的el-table表头的溢出隐藏悬浮

正常情况我们是用v-for遍历渲染表格；

```vue
//渲染内容的代码：
<template slot-scoped="scoped">
    .....里面写我们的字段循环
</template>

//渲染表头的的溢出隐藏数据(与上面并列写)
<template slot="header" slot-scoped="slot">
	//表头盒子(创建鼠标经过监听事件，用来计算文本的offsetWidth和scrollWidth，比较大小确定是否启用悬浮)
	<div class="header_box" @mouseover.stop="getHaderTooltip(slot.column.id)">
        //悬浮区(根据比较的大小动态控制disabled的值，控制悬浮的启用)
        <el-tooltip :disabled="isShowTooltip" class="item" :content="slot.column.label" placement="top">
    		//表头(动态设置ref)
            <div :ref="slot.column.id" class="long_title">{{slot.column.label}}</div>
    	</el-tooltip>
    </div>
</template>

//鼠标移入比较可视区可盒子的offsetWidth和scrollWidth，注意scrollWidth包括溢出的大小
getHaderTooltip(idRef){
	const contentOffsetWidth = this.$refs[idRef][0].offsetWidth;
	const contentScrollWidth = this.$refs[idRef][0].scrollWidth;
	if(contentOffsetWidth < contentScrollWidth){
    	this.isShowTooltip = false;
	}else{                                         
        this.isShowTooltip = true;                                      
    }
}
```

#### 21、关于getBoundingClientRect()原生js方法设置吸顶效果

getBoundingClientRect用于获取某个元素相对于视窗的位置集合。集合中有top, right, bottom, left等属性。

```js
//获取到DOM元素 el

rectObject = el.getBoundingClientRect();
//返回值为对象，里面有关于视口位置的属性：
rectObject.top：元素上边到视窗上边的距离;

rectObject.right：元素右边到视窗左边的距离;

rectObject.bottom：元素下边到视窗上边的距离;

rectObject.left：元素左边到视窗左边的距离;

rectObject.width：元素的宽度;

rectObject.height：元素的高度;

//可以根据top值是否大于0动态classList.add()和classList.remove()添加和移除类名，来设置定位吸顶
```

#### 22、关于修改默认滚动条的样式

目前支持修改默认的滚动条样式的只有IE/Chrome/Firefox:

IE:只支持下面滚动条的样式修改。

```css
scrollbar-arrow-color: color; /*三角箭头的颜色*/
scrollbar-face-color: color; /*立体滚动条的颜色（包括箭头部分的背景色）*/
scrollbar-3dlight-color: color; /*立体滚动条亮边的颜色*/
scrollbar-highlight-color: color; /*滚动条的高亮颜色（左阴影？）*/
scrollbar-shadow-color: color; /*立体滚动条阴影的颜色*/
scrollbar-darkshadow-color: color; /*立体滚动条外阴影的颜色*/
scrollbar-track-color: color; /*立体滚动条背景颜色*/
scrollbar-base-color:color; /*滚动条的基色*/
```

Firefox(火狐)：

```css
scrollbar-color ： 设置滚动条轨道和拇指的颜色
scrollbar-width ：设置滚动条出现时的厚度

例：
颜色：
scrollbar-color: auto;
scrollbar-color: dark;
scrollbar-color: light;
或其他颜色，第一个是滑块颜色，第二个是轨道颜色
scrollbar-color: green #fff;

厚度：
scrollbar-width：none/thin/auto

auto	系统默认的滚动条宽度
thin	系统提供的瘦滚动条宽度，或者比默认滚动条宽度更窄的宽度
none	不显示滚动条，但是该元素依然可以滚动
```

Chrome(谷歌)：

```css
::-webkit-scrollbar： 整个滚动条.
::-webkit-scrollbar-button ： 滚动条上的按钮 (上下箭头).
::-webkit-scrollbar-thumb ： 滚动条上的滚动滑块.
::-webkit-scrollbar-track ： 滚动条轨道.
::-webkit-scrollbar-track-piece ： 滚动条没有滑块的轨道部分.
::-webkit-scrollbar-corner ： 当同时有垂直滚动条和水平滚动条时交汇的部分.
::-webkit-resizer ： 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).

例：
整体部分必须写
/*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/
::-webkit-scrollbar {
width: 10px; /*对垂直流动条有效*/
height: 10px; /*对水平流动条有效*/
}
/*定义滚动条的轨道颜色、内阴影及圆角*/
::-webkit-scrollbar-track{
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);
background-color: rosybrown;
border-radius: 3px;
}
/*定义滑块颜色、内阴影及圆角*/
::-webkit-scrollbar-thumb{
border-radius: 7px;
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);
background-color: #E8E8E8;
}
/*定义两端按钮的样式*/
::-webkit-scrollbar-button {
background-color:cyan;
}
/*定义右下角汇合处的样式*/
::-webkit-scrollbar-corner {
background:khaki;
}
```



#### 23、关于Element的一些常用的知识点

##### (1)、全局loading的封装

```js
import {Loading} from "element-ui";

let _loading;
let loadingType = true;

//1、创建loading实例
export const showLoading = () => {
    if(!loadingType) return
    _loading = Loading.service({
        lock:true,
        body:true,
        text:"正在加载中......",
        background:"rgba(255,255,255,.5)",
        target:"#app",
        fullscreen:false,
        customClass:"custom-loading"
    });
    loadingType = false;
}

//2、关闭loading实例
export const hideLoading = () => {
    _loading.close();
    loadingType = true;
}
```

##### (2)、el-autocomplete二次封装

1、子组件CustomAutoComplete.vue：

```vue
<template>
  <el-autocomplete
    v-model="modelData"
    :placeholder="placeHolder"
    :disabled="disabled"
    oninput="value = value.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g,'')"
    :value-key="valueKey"
    :fetch-suggestions="querySearch"
    @select="handleSelect"
    @focus="$emit('focus', $event)"
  >
    <template slot-scope="{ item }" v-if="isTempalte">
      <div class="name">{{ item.id }}</div>
      <span class="addr">{{ item.name }}</span>
    </template>
  </el-autocomplete>
</template>

<script>
export default {
  name: 'CustomAutoComplete',
  // 用于自定义组件的v-model的传递事件和值
  model: {
    prop: 'data',
    event: 'blur',
  },
  props: {
    // 该值和model的值一致，此处接收，上面是申明
    // 1、绑定值
    data: {
      required: true,
    },
    // 2、占位
    placeHolder: {
      type: String,
      default: '请输入内容',
    },
    // 3、是否禁用状态
    disabled: {
      type: Boolean,
      default: false,
    },
    // 4、是否成采用自定义模板
    isTemplate: {
      type: Boolean,
      default: false,
    },
    // ......其余可根据实际需求传递参数
  },
  data() {
    return {
      modelData: this.data, //组件内显示的值
    };
  },
  computed: {
    // 输入建议对象中用于显示的键名(可根据实际需求去写)
    valueKey() {
      return id; //根据需求去设置获取的数据中显示的字段，不设置默认展示全部返回的字段数据
    },
  },
  watch: {
    // 此处监听modelData，只要变化即传递给父组件，同步更新变化值，防止子组件改变了值但是父组件未同步改变
    // 用blur是因为model设置了v-model的同步事件是blur
    modelData(val) {
      this.$emit('blur', val);
    },
  },
  methods: {
    // 联想搜索的方法(返回输入建议的方法，仅当你的输入建议数据 resolve 时，通过调用 callback(data:[]) 来返回它)
    // 第一个参数是输入的内容，第二个是请求完成后需要执行的回调函数
    querySearch(queryString, callback) {
      // 1、 ...此处可以对参数进行自定义的调整，如多个地方使用该组件但是请求不一样，可以设置判断并传递不同的参数
      // 2、发送请求，请求数据res
      // 3、执行回调函数，下拉显示该数据
      callback(res);
    },
    // 选择显示的数据，并传递给父组件
    handleSelect(item) {
      this.$emit('handleSelectBack', item);
    },
  },
};
</script>

<style></style>
```

2、父组件Father.vue：

```vue
<template>
  <CustomAutoComplete
    v-model="query.autoData"
    :disabled="true"
    placeHolder="请输入"
    :isTemplate="false"
    @handleSelectBack="selectAuto"
    @focus="getFocus"
  />
</template>

<script>
import CustomAutoComplete from './CustomAutoComplete.vue';
export default {
  name: 'Father',
  components: { CustomAutoComplete },
  data() {
    return {
      query: {
        autoData: '',
      },
    };
  },
  methods: {
    // 接收选择的下拉选项
    selectAuto(item) {
      // ...此处可以根据需求进行自定义的选择，当同一个页面多个地方同时接收但是展示的不一样，就可以自行选择
      this.$set(this.query, 'autoData', item.id);
    },
    // 子组件中传递出来的focus事件，我们可以根据需求在该事件中做一些自定义的操作
    getFocus() {},
  },
};
</script>

<style>
</style>
```

#### 24、关于vue.config.js的一些配置

```js
module.exports = {
    // 配置打包入口
    chainWebpack: config => {
        // 发布模式：发布环境（运行）的打包路口配置
        config.when(process.env.NODE_ENV === 'production', config => {
            config.entry('app').clear().add('./src/main-prod.js')

            // 配置externals不打包信息
            // (注意：左侧多单词名称用-连接时会报错，需再加引号)
            config.set('externals', {
                vue: 'Vue',
                'vue-router': 'VueRouter',
                axios: 'axios',
                lodash: '_',
                echarts: 'echarts',
                nprogress: 'NProgress',
                'vue-quill-editor': 'VueQuillEditor',
            })

            // 配置发布模式下的isProd
            config.plugin('html').tap(args => {
                args[0].isProd = true	//生产环境做标识，下面用于设置title
                // args[0].title = '电商系统' //当然此处也可以直接写
                return args
            })

        })

        // 开发模式：开发环境的打包路口配置
        config.when(process.env.NODE_ENV === 'development', config => {
            config.entry('app').clear().add('./src/main-dev.js')

            // 配置开发模式下的isProd
            config.plugin('html').tap(args => {
                args[0].isProd = false	//开发环境做标识，下面用于设置title
                // args[0].title = 'dev-电商系统' //当然此处也可以直接写
                return args
            })
        })
    },
    lintOnSave: false
}
```

html模板文件中：

```html

	<title>
        <%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %>电商后台管理系统
    </title>

```

#### 25、动态追加路由(根据文件)

```js
const routeFiles = require.context('../pages', true, /\.vue/) // 读取views文件夹下面所有的.vue文件
routeFiles.keys().forEach(item => {
  // console.log(item)
  if (item.indexOf('component') === -1) { // component下面为子组件不需要注册路由
    let info = item.split('.')
    routes.push({
      path: info[1],
      component: routeFiles(item).default
    })
  }
})
```

#### 26、关于处理城市数据成树结构

```js
案例：城市数组，转换成树结构
let treeList = [{
	title: "广东省",
	id: "100000",
	parentId: null
}, {
	title: "深圳市",
	id: "100100",
	parentId: '100000'
}, {
	title: "广州市",
	id: "100200",
	parentId: '100000'
}, {
	title: "江西省",
	id: "200000",
	parentId: null
}, {
	title: "上饶市",
	id: "200100",
	parentId: "200000"
}, {
	title: "南昌市",
	id: "200200",
	parentId: "200000"
}, {
	title: "德兴市",
	id: "200300",
	parentId: "200000"
}, ]

//转换结果如下(由于复制原因下面显示的是json格式，结果是对象格式，下面格式请忽略)：
[
    {
        "title": "广东省",
        "id": "100000",
        "parentId": null,
        "children": [
            {
                "title": "深圳市",
                "id": "100100",
                "parentId": "100000"
            },
            {
                "title": "广州市",
                "id": "100200",
                "parentId": "100000"
            }
        ]
    },
    {
        "title": "江西省",
        "id": "200000",
        "parentId": null,
        "children": [
            {
                "title": "上饶市",
                "id": "200100",
                "parentId": "200000"
            },
            {
                "title": "南昌市",
                "id": "200200",
                "parentId": "200000"
            },
            {
                "title": "德兴市",
                "id": "200300",
                "parentId": "200000"
            }
        ]
    }
]


//方法一：先把省和市分开，再合并
function composeCity(data) {
	let father = [];
	let son = [];
	data.forEach(item => {
		if (item.parentId == null) {
			father.push({
				...item,
				children: []
			});
		} else {
			son.push(item);
		}
	});
	son.map(item => {
		father.forEach(list => {
			if (item.parentId === list.id) {
				list.children.push(item)
			}
		})
	})
	return father
}
let citys = composeCity(treeList);


//方法二：遍历并过滤追加市区，再过滤提取省份
function transTree(treeList) {
	treeList.forEach(list => {
		let result = treeList.filter(item => list.id == item.parentId)
		if (result.length > 0) {
			list.children = result
		}
	})
	let root = treeList.filter(item => item.parentId == null)
	return root
}
transTree(treeList)
```

#### 27、关于window的message事件和postMessage

疑问：一个页面里面点击打开了一个新的窗口，然后在新的窗口里面保存成功数据之后需要更新前面一个窗口的数据？应该怎么实现呢？

window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。

window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。

从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。

接收消息的窗口可以根据需要自由处理此事件。传递给 window.postMessage() 的参数（比如 message ）将通过消息事件对象暴露给接收消息的窗口。
————————————————
*版权声明：本文为CSDN博主「凯小默」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。*
*原文链接：https://blog.csdn.net/kaimo313/article/details/107773642*

实例：

demo1.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>demo-1</title>
</head>
<body>
  <div id="demo-1">demo-1页面</div>
  <button id="btn">点击跳转到demo-2</button>
  <script>
    // 添加点击事件
    document.getElementById('btn').addEventListener('click', () => {
      window.open('./demo-2.html');
    });
    // 监听window的message窗口信息传递事件(回调函数中接收信息，相当于事件总线的接收)
    window.addEventListener('message', event => {
      // 我们能信任信息来源吗？
      if (event.origin !== window.location.origin) {
        alert('我们不能信任信息来源!!!!!')
        return;
      }
      console.log(event);
      alert(event.data.message)
    })
  </script>
</body>
</html>
```

demo2.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>demo-2</title>
</head>
<body>
  <div id="demo-2">demo-2页面</div>
  <button id="save">保存</button>
  <script>
    // 添加点击事件
    document.getElementById('save').addEventListener('click', () => {
      // 传递窗口信息(类似事件总线的发送)
      window.opener.postMessage({
        name: 'demo-2',
        message: '凯小默保存成功啦啦啦啦！！！！'
      }, window.location.origin);
    });
  </script>
</body>
</html>
```

#### 28、document.execCommand()用法，此处只阐述复制

详情参考地址：https://www.cnblogs.com/watercaltrop/articles/4689279.html

```js
const textarea = document,createElement("textarea");
let str = "这是要复制的内容";
textarea.value = str;
document.body.appendChild(textarea);
textarea.select();
document.execCommand("Copy");
textarea.remove()
```

#### 29、关于文件的下载

```vue
<template>
  <div class="download">
    <p>这是下载测试的页面</p>
    <el-upload
      class="avatar-uploader"
      action="https://jsonplaceholder.typicode.com/posts/"
      :show-file-list="false"
      :on-change="change"
      :auto-upload="false"
      >
      <img v-if="imageUrl" :src="imageUrl" class="avatar" />
      <i v-else class="el-icon-plus avatar-uploader-icon"></i>
    </el-upload>
    <button @click="download">下载</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      imageUrl: "",
      base64: "",
    };
  },
  methods: {
    change(file) {
			// URL.createObjectURL接收的参数是blob或者file对象，注意我们上传文件的file.raw本身就是blob文件流
      this.imageUrl = URL.createObjectURL(file.raw);//转成可识别的url，前缀是blob：
      const fileReader = new FileReader();
			// fileReader.readAsDataURL接收的参数是blob或者file对象，注意我们上传文件的file.raw本身就是blob文件流
      fileReader.readAsDataURL(file.raw);//转换成base64的编码
			// 由于readAsDataURL是异步的，需要在onload事件中执行自定义的逻辑
      fileReader.onload = (e) => {
        this.base64 = e.target.result.split(",")[1];//拿到的是带类型前缀的base64，此处移除前缀
      };
    },
    download() {
			// 有些浏览器没有msSaveBlob方法，此处需要判断
			// msSaveBlob可识别base64直接下载，此处也可以直接用blob对象，如file.raw
      if (window.navigator?.msSaveBlob) {
          //ie浏览器
        window.navigator.msSaveBlob(this.base64, "这是下载文件.jpg");
      } else {
				// 不支持的用a链接执行可识别的blob的url进行下载
        const a = document.createElement("a");
        a.href = this.imageUrl;//注意这个地址不能是base64，可以是blob的url，不可以是blob对象本身
        a.download = "这是下载文件.jpg";
        const evn = document.createEvent("HTMLEvents");//创建元素的事件类型
        evn.initEvent("click", true, true);//初始化元素上的点击事件
        a.click();//监听事件，可以用addEventLinstener写
        a.dispatchEvent(evn);//触发这个事件
      }
    },
  },
};
</script>
```

##### 1、自定义的blob文件下载

```js
download() {
	const blobObject = new Blob(["这是一段测试的下载文本"],{type:'txt'});//创建一个blob文件流对象,可以自定义type文件类型
	if (window.navigator?.msSaveBlob) {
        //msSaveBlob中的参数可以是base64的文件编码也可以是blob文件对象
		window.navigator.msSaveBlob(blobObject, "msSaveBlob_testFile.txt");
	} else {
		// 不支持的用a链接执行可识别的blob的url进行下载
		const url = URL.createObjectURL(blobObject);
		const a = document.createElement("a");
		a.href = url; //注意这个地址不能是base64，可以是blob的url，不可以是blob对象本身
		a.download = "下载文本.txt";
		const evn = document.createEvent("HTMLEvents"); //创建元素的事件类型
		evn.initEvent("click", true, true); //初始化元素上的点击事件
		a.click(); //监听事件，可以用addEventLinstener写
		a.dispatchEvent(evn); //触发这个事件
	}
},
```

完整模拟用bloburl或blob对象下载文件及缓存：

```js
<template>
  <div>
    这是测试文件下载的模块
    <el-upload
      class="upload-demo"
      action="https://jsonplaceholder.typicode.com/posts/"
      :on-change="handleChange"
      :file-list="fileList"
      :auto-upload="false"
    >
      <el-button size="small" type="primary">点击上传</el-button>
    </el-upload>
    <button @click="download" style="margin: 20px">下载</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      fileList: [], //文件列表数据
      fileBlobUrl: "", //bloburl的临时文件地址
      name: "", //文件名
      base64: "", //文件对象的base64码
      blob: null, //blob文件对象
    };
  },
  methods: {
    // 上传（由于暂时没有后台，因此此处演示一下:
    //（1）、blob对象=>bloburl
    //（2）、blob对象=>base64=>blob
    // ）
    handleChange(file, fileLists) {
      // 获取bloburl地址
      this.fileBlobUrl = URL.createObjectURL(file.raw);
      // 获取base64地址
      const fileReader = new FileReader();
      fileReader.readAsDataURL(file.raw);
      fileReader.onload = (e) => {
        this.base64 = e.target.result.split(",")[1]; //把blob对象转为base64
        this.blob = this.dataURLtoBlob(e.target.result); //把base64转为blob对象
      };
      this.name = file.name;
      // 列表展示用
      this.fileList.push({
        name: file.name,
        url: URL.createObjectURL(file.raw), //转换成src可识别的bloburl地址
      });
    },
    // 下载：
    // 正常情况如果使用bloburl下载的文件，这个bloburl临时地址会存在浏览器缓存；
    // 因此下次再使用该地址去下载就不会去请求后台，直接从浏览器缓存中取这个文件；
    // 当然如果手动清除了浏览器缓存的话，由于这个地址还存在，但是文件不存在，因此会下载空文件
    download() {
      if (window.navigator?.msSaveOrOpenBlob) {
        // ie浏览器
        // 情形一：根据bloburl地址去下载，需先根据地址请求到blob文件
        const xml = XMLHttpRequest();
        xml.open("GET", this.fileBlobUrl);
        xml.responseType = "blob";
        xml.onload = (res) => {
          window.navigator.msSaveOrOpenBlob(res.response, this.name);
        };
        // 情形二：给到的参数就是blob文件对象，直接下载
        // window.navigator.msSaveOrOpenBlob(this.blob, "测试");
      } else {
        // 其他浏览器
        const a = document.createElement("a");
        // 情形一：根据bloburl地址去下载，a标签可直接识别bloburl地址
        // a.href = this.fileBlobUrl;
        // 情形二：给到的参数就是blob文件对象，a标签不能识别，需转成bloburl地址
        a.href = URL.createObjectURL(this.blob);
        a.download = this.name;
        const evt = document.createEvent("HTMLEvents");
        evt.initEvent("click", true, true);
        a.click();
        a.dispatchEvent(evt);
      }
    },
    // base64文件代码转换成blob对象(一般后台都会给base64代码去下载文件)
    dataURLtoBlob(dataurl) {
      var arr = dataurl.split(",");
      var bstr = atob(arr[1]);
      var n = bstr.length;
      var mime = arr[0].match(/:(.*?);/)[1];
      var u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new Blob([u8arr], { type: mime }); //返回的就是blob对象
    },
  },
};
</script>

<style lang="less" scoped>
</style>
```



#### 30、使用canvas给页面加水印

封装添加水印的js函数：

```js
const watermark = {};
const setWatermark = (str, element) => {
  // 如果未指定加水印的盒子则返回
  if (!element) {
    return;
  }
  // 创建唯一的id作为水印盒子
  const id = "1.23452384164.123412416";
  // 如果已经存在时但是再次调用该方法则先移除原有的水印
  if (document.getElementById(id) !== null) {
    document.getElementById(element).removeChild(document.getElementById(id));
  }

  // 创建一个画布
  const can = document.createElement("canvas");
  // 设置画布的长宽
  can.width = 120;
  can.height = 120;

  const cans = can.getContext("2d");
  // 旋转角度
  cans.rotate((-15 * Math.PI) / 180);
  cans.font = "18px Vedana";
  // 设置填充绘画的颜色、渐变或者模式
  cans.fillStyle = "rgba(200, 200, 200, 0.40)";
  // 设置文本内容的当前对齐方式
  cans.textAlign = "left";
  // 设置在绘制文本时使用的当前文本基线
  cans.textBaseline = "Middle";
  // 在画布上绘制填色的文本（输出的文本，开始绘制文本的X坐标位置，开始绘制文本的Y坐标位置）
  cans.fillText(str, can.width / 8, can.height / 2);

  // 创建水印盒子并添加属性
  const div = document.createElement("div");
  div.id = id;
  div.style.pointerEvents = "none";
  div.style.top = "0px";
  div.style.left = "0px";
  div.style.position = "absolute";
  div.style.zIndex = "100000";
  div.style.width = "100%";
  div.style.height = "100%";
  // div.style.width = document.documentElement.clientWidth + "px";//可根据需求是全局body加还是指定元素上加
  // div.style.height = document.documentElement.clientHeight + "px";//可根据需求是全局body加还是指定元素上加
  div.style.background =
    "url(" + can.toDataURL("image/png") + ") left top repeat";
  // 把水印元素div追加到指定的盒子内
  document.getElementById(element).appendChild(div);
  // id返回出去，用于后续判断该函数是否有返回值来确认是否创建水印盒子完成
  return id;
};

// 该方法只允许调用一次(调用创建水印)
watermark.set = (str, element) => {
  let id = setWatermark(str, element);
  // 500毫秒内如果没创建成功就继续创建
  setInterval(() => {
    if (document.getElementById(id) === null) {
      id = setWatermark(str, element);
    }
  }, 500);
  // 窗口大小变化时重新加载水印
  window.onresize = () => {
    setWatermark(str, element);
  };
};

export default watermark;

```

调用方法添加水印：

```js
waterMask.set("这是水印",'box')
```

注意：由于水印盒子设置了绝对定位，因此需要加水印的盒子应该设置相对定位，请知悉！

#### 31、预览word文件doc

1、安装插件**`npm i docx-preview --save`**

2、调用该插件的renderAsync方法，接收两个参数，第一个是需要预览的doc文件的blob对象(注意不是bloburl)，第二个参数是需要渲染到页面的dom元素，使用ref；

代码如下：实现预览和下载。

```vue
<template>
  <div class="preview-doc">
    <p>模拟上传来获取文件地址</p>
    <div class="box">
      <el-upload class="upload-demo" ref="upload" action="https://jsonplaceholder.typicode.com/posts/" :on-change="changeFile" :file-list="fileList" :auto-upload="false">
        <el-button slot="trigger" size="small" type="primary">选取文件</el-button>
      </el-upload>
      <el-button @click="download" size="small" type="primary">下载</el-button>
      <div class="doc-mask" v-if="showDoc">
        <div class="doc-box">
          <div class="doc-content">
            <!-- 预览文件的地方（用于渲染） -->
            <div ref="file"></div>
          </div>
          <div class="close">
            <el-button @click="showDoc = false">关闭</el-button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
// 引入docx-preview插件
let docx = require("docx-preview");
export default {
  data() {
    return {
      fileList: [],
      fileBlobUrl: "",
      showDoc: false,
    };
  },
  mounted() {
    console.log("使用插件的renderAsync方法来渲染", docx); //
  },
  methods: {
    // 文件改变时
    changeFile(file, fileList) {
      console.log(file, fileList);
      // 获取bloburl地址
      // this.fileBlobUrl = URL.createObjectURL(file.raw);
      // console.log(this.fileBlobUrl);
      this.blobFile = file.raw; //获取文件 blob对象
      this.showDoc = true;
      this.$nextTick(()=>{
      	docx.renderAsync(this.blobFile, this.$refs.file);
        // 渲染到页面(注意第一个参数是blob对象而不是bloburl，第二个参数是要渲染的dom元素)
      })
    },
    // 下载
    download() {
      // const blob = new Blob([this.fileBlobUrl]); // 把得到的结果用流对象转一下
      // const blobURL = window.URL.createObjectURL(new Blob([this.blobFile]));//转成bloburl
      const blobURL = window.URL.createObjectURL(this.blobFile); //转成bloburl
      let a = document.createElement("a"); //创建一个<a></a>标签
      a.href = blobURL; //赋值链接
      a.download = "测试.docx"; //设置文件名
      a.style.display = "none"; // 障眼法藏起来a标签
      document.body.appendChild(a); // 将a标签追加到文档对象中
      a.click(); // 模拟点击了a标签，会触发a标签的href的读取，浏览器就会自动下载了
      a.remove(); // 一次性的，用完就删除a标签
    },
  },
};
</script>

<style lang="less">
.box {
  display: flex;
  .el-button {
    height: 36px;
    margin-right: 10px;
  }
}
.doc-mask {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
  .doc-box {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    display: flex;
    flex-direction: column;

    .doc-content {
      width: 900px;
      height: 700px;
      overflow: auto;
    }
    .close {
      margin: 10px auto;
    }
  }
}
</style>

```

#### 32、预览pdf文件

1、下载pdf.js：文件夹pdf = build文件夹 + web文件夹 等；

2、把文件夹放到public文件夹下，作为静态文件复制到打包后的文件中；

3、使用iframe内嵌的方式去打开pdf文件或者使用window.open以新页面的形式预览pdf;

```html
/*内嵌方式：*/
<iframe :src="./pdf/web/viewer.html?file=这里填对应的文件url" style="width:100%;hegiht:100;"></iframe>
```

```js
//新页面方式
window.open("./pdf/web/viewer.html?file=这里填对应文件url"，_blank);
```

#### 33、element-plus的局部引入

具体完整引入和按需引入可以参考官网：https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E5%AE%8C%E6%95%B4%E5%BC%95%E5%85%A5

![image-20220219211917307](C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220219211917307.png)

![image-20220219211951371](C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220219211951371.png)

![image-20220219212010634](C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220219212010634.png)

以上取至官网对于vue3的ui库element-plus的全部和按需导入的方式描述。

全部引入没有问题，但是按需导入经测试发现还是有问题的。

关于按需引入的问题：正常标签组件是没有问题的，采用了按需导入的方式，只需要在vue.config.js或者vite.config.ts中配置好对应的配置信息，在使用element-plus的组件，都可以直接用，并不需要再单独导入组件，样式也是，并不需要单独导入，但是有个问题就是非标签组件，如loading、message等反馈组件在通过按需导入使用时，该组件的样式文件并不会被导入进来，即缺少样式文件，导致样式失效。

因此针对按需导入的方式使用element-plus，就必须解决这些反馈组件样式文件未导入的问题。

具体描述亦可参考文章：https://xie.infoq.cn/article/e576f022653a7e0cb872038f1

百度查询了很多该问题，得到的解决方式都是使用**unplugin-element-plus**插件，该插件git地址：https://github.com/element-plus/unplugin-element-plus/blob/HEAD/README.zh-CN.md

![image-20220219213231595](C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220219213231595.png)

从中可以看到该插件会根据导入的组件去自动导入该组件对应的样式文件，而组件的导入我们是通过按需加载的那两个插件实现了。

使用：

- 安装：
- vite.config.ts配置：![image-20220219213644889](C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220219213644889.png)
- 或者vue.config.js配置：![](C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220219214224784.png)

补充：

1. 需要注意经测试发现其实引入的文件是scss的样式文件，因此就需要安装sass-loader、sass等依赖(直接安装即可，可能存在版本不兼容问题则降低版本)。
2. 当然要是觉得按照官网的按需导入之后还需要这么麻烦去解决反馈组件的样式问题，那么也可直接在main.ts中导入全局的样式index.css，这样也可以，无非就是多导入了样式文件。
3. 当然这只是仅限于当下版本的element-plus出现的问题而产生的解决方法，不排除后续版本更新修复官网按需导入所暴露的该问题，目前element-plus 2.0.2版本存在该问题
4. 该文编著于2022.0219
5. 另补充一点：之前网上有*使用**babel-plugin-import**插件导入样式文件+手动遍历导入组件注册*来替代官网的按需导入，但是由于element-plus新版本的原因导致目录结构等的变化，导致该插件来对组件的按需导入会出现异常，因此暂时无法使用该组件来实现按需导入样式表。



#### 34、Vue3 + ts中权限动态路由的思路及方法

在后台管理系统中，由于不同用户拥有不同的操作权限，登录后所能操作和的菜单并不一样，因此就需要对路由进行动态控制。

**思路：**

- 后台返回用户所能访问的权限菜单，包含path路径(该路径需要前端提供，保证前后端一致，和路由的路径对应)；
- 目录结构的设计(为了方便扩展和维护，设计好目录结构)：
  - 组件目录结构如下：属于登录后的菜单组件全部放于*main*文件夹中，每一个大菜单创建一个文件夹，在大菜单文件夹中创建子菜单的文件夹，并在子菜单文件夹中创建子菜单组件文件。
  - <img src="C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220304111309216.png" alt="image-20220304111309216" style="zoom: 67%;" />
  - 组件路由导出目录结构如下：在router文件夹中创建main文件夹，用于存放所有权限菜单的导出，和上面组件的结构层级一致，并在ts文件中写如下代码，导出路由类型的对象。

<img src="C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220304112209040.png" alt="image-20220304112209040" style="zoom:67%;" />

- 在*utils*中创建一个公共方法，用于处理收集全部导出的路由，并根据获取的菜单从全部导出的路由中筛选当前用户权限范围内的路由。

<img src="C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220304134132264.png" alt="image-20220304134132264" style="zoom:67%;" />

- 根据开发实际情况，调用上方导出的方法，来获取筛选到当前用户的权限范围内的路由，并把这些路由动态追加到路由对象中。

<img src="C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220304135549731.png" alt="image-20220304135549731" style="zoom:67%;" />

补充：附上最开始路由表

<img src="C:\Users\19979357151\AppData\Roaming\Typora\typora-user-images\image-20220304135704160.png" alt="image-20220304135704160" style="zoom:67%;" />

​		

#### 35、ts中关于axios的封装(包含取消请求)

参考地址：https://mp.weixin.qq.com/s/XMZBpVyvC4wKrnj0j--49A

本实例具体是在vue3中+elemeng-plus实施的，中间会夹杂部分其他代码；

1.类型的文件代码(type.ts)：

```ts
import { AxiosRequestConfig, AxiosResponse } from "axios";

/* 为了增加扩展性，我们让实例传递拦截器函数，也就是实例需要传递默认的AxiosRequestConfig
类型的参数，同时要具备拦截器中函数参数类型，因此此处需要进行一些操作，去扩展实例传递的
参数类型 */
// 1.汇总拦截器各函数的参数类型
interface ALRequestInterceptors<T = AxiosResponse> {
  requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig;
  requestInterceptorCatch?: (error: any) => any;
  responseInterceptor?: (config: T) => T;
  responseInterceptorCatch?: (error: any) => any;
}
// 2.重构总的参数类型
interface ALRequestConfig<T = AxiosResponse> extends AxiosRequestConfig {
  interceptors?: ALRequestInterceptors<T>;
  showLoading?: boolean;
}

export { ALRequestConfig, ALRequestInterceptors };

```

2.对axios类封装完整的代码(index.ts)：

```ts
// 对axios进行二次封装
import axios from "axios";
import { AxiosInstance } from "axios";
import type { ALRequestConfig, ALRequestInterceptors } from "./type";
import { ElLoading } from "element-plus";
import { LoadingInstance } from "element-plus/es/components/loading/src/loading";
import LocalCache from "@/utils/cache";
const DEFAULT_LOADING = true; //设置默认不加载loading
// 请求的封装类
class ALRequest {
  //1.构建属性axios的实例及自定义的拦截器函数
  instance: AxiosInstance;
  interceptors?: ALRequestInterceptors;
  showLoading: boolean;
  loading?: LoadingInstance;
  //2.构造器创建实例初始化公共参数
  constructor(config: ALRequestConfig) {
    this.instance = axios.create(config);
    this.interceptors = config.interceptors;
    this.showLoading = config.showLoading ?? DEFAULT_LOADING;
    // 3.封装实例特有的拦截器
    this.instance.interceptors.request.use(
      this.interceptors?.requestInterceptor,
      this.interceptors?.requestInterceptorCatch
    );
    this.instance.interceptors.response.use(
      this.interceptors?.responseInterceptor,
      this.interceptors?.responseInterceptorCatch
    );
    // 5.添加所有请求公共的拦截器
    this.instance.interceptors.request.use(
      (config) => {
        const token = LocalCache.getCache("token") ?? "";
        // 由于headers没有内置Authorization属性，因此前面加!强调有该属性，否则ts检测会报错
        config.headers!.Authorization = `Bearer ${token}`;
        // 加载loading;
        console.log(this.showLoading);

        if (this.showLoading) {
          this.loading = ElLoading.service({
            lock: true,
            text: "Loading",
            background: "rgba(0, 0, 0, 0.7)"
          });
        }
        return config;
      },
      (error) => {
        return error;
      }
    );
    this.instance.interceptors.response.use(
      (config) => {
        this.loading?.close();
        return config.data;
      },
      (error) => {
        this.loading?.close();
        return error;
      }
    );
  }
  //4.封装请求(细化到对单个请求的拦截器进行处理)
  request<T = any>(config: ALRequestConfig<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      // 1.如果单个请求携带了自定义的拦截器，则对参数进行拦截器处理
      if (config.interceptors?.requestInterceptor) {
        config = config.interceptors.requestInterceptor(config);
      }
      // 2.判断是否需要展示loading(注意此处是请求前，还未开始执行上面的请求拦截)
      if (config.showLoading == false) {
        this.showLoading = config.showLoading;
      }

      this.instance
        .request<any, T>(config)
        .then((res) => {
          if (config.interceptors?.responseInterceptor) {
            res = config.interceptors.responseInterceptor(res);
            // 重置loading为true，这样不会影响下一个请求
            this.showLoading = DEFAULT_LOADING;
          }
          resolve(res);
        })
        .catch((err) => {
          // 重置loading为true，这样不会影响下一个请求
          this.showLoading = DEFAULT_LOADING;
          reject(err);
        });
    });
  }
  get<T = any>(config: ALRequestConfig<T>): Promise<T> {
    return this.request({ ...config, method: "GET" });
  }
  post<T = any>(config: ALRequestConfig<T>): Promise<T> {
    return this.request({ ...config, method: "POST" });
  }
  delete<T = any>(config: ALRequestConfig<T>): Promise<T> {
    return this.request({ ...config, method: "DELETE" });
  }
  patch<T = any>(config: ALRequestConfig<T>): Promise<T> {
    return this.request({ ...config, method: "PATCH" });
  }
}

export default ALRequest;

```

3.创建的请求实例代码(index.ts)：

```ts
import ALRequest from "./request";
import { BASE_URL, TIME_OUT } from "./request/config";

// 请求实例1：
const alRequest = new ALRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,
  interceptors: {
    requestInterceptor: (config) => {
      return config;
    },
    requestInterceptorCatch: (error) => {
      return error;
    },
    responseInterceptor: (config) => {
      return config;
    },
    responseInterceptorCatch: (error) => {
      return error;
    }
  }
});

export { alRequest };
```

4.部分常量代码(config.ts)：

```ts
// 定义公共的常量参数
let BASE_URL = "";
const TIME_OUT = 10000;
if (process.env.NODE_ENV == "development") {
  BASE_URL = "http://152.136.185.210:5000";
}
if (process.env.NODE_ENV == "production") {
  BASE_URL = "http://152.136.185.210:5000";
}
export { BASE_URL, TIME_OUT };

```

5.部分实际接口请求代码：

```ts
import { alRequest } from "../index";
import { IAccount, ILoginResult, IUserInfo } from "./types";
import { IDataType } from "../types";
// 定义枚举类：存放登录的请求api
enum LoginApi {
  AccountLogin = "/login",
  LoginUserInfo = "/users/", // /users/ + id
  UserMenus = "/role/" // /role/ + role + /menu
}
// 1.账户登录接口
export function accountLoginRequest(account: IAccount) {
  return alRequest.post<IDataType<ILoginResult>>({
    url: LoginApi.AccountLogin,
    data: account
  });
}
```

6.补充点：取消请求

上述封装并没有包含参考地址的文章中的取消请求的内容，因此此处单独把这部分内容从文章中提取出来。

以下内容摘抄自文章。

- 准备工作：

​	我们需要将所有请求的取消方法保存到一个集合（这里我用的数组，也可以使用Map）中，然后根据具体需要去调用这个集合中的某个取消请求方法。

首先定义两个集合，示例代码如下：

```ts
// index.ts
import type {
  RequestConfig,
  RequestInterceptors,
  CancelRequestSource,
} from './types'

class Request {
  /*
  存放取消方法的集合
  * 在创建请求后将取消请求方法 push 到该集合中
  * 封装一个方法，可以取消请求，传入 url: string|string[] 
  * 在请求之前判断同一URL是否存在，如果存在就取消请求
  */
  cancelRequestSourceList?: CancelRequestSource[]
  /*
  存放所有请求URL的集合
  * 请求之前需要将url push到该集合中
  * 请求完毕后将url从集合中删除
  * 添加在发送请求之前完成，删除在响应之后删除
  */
  requestUrlList?: string[]

  constructor(config: RequestConfig) {
    // 数据初始化
    this.requestUrlList = []
    this.cancelRequestSourceList = []
  }
}
```

这里用的`CancelRequestSource`接口，我们去定义一下：

```ts
// type.ts
export interface CancelRequestSource {
  [index: string]: () => void
}
```

这里的`key`是不固定的，因为我们使用`url`做`key`，只有在使用的时候才知道`url`，所以这里使用这种语法。

- 取消请求方法的添加与删除

首先我们改造一下`request()`方法，它需要完成两个工作，一个就是在请求之前将`url`和取消请求方法`push`到我们前面定义的两个属性中，然后在请求完毕后（不管是失败还是成功）都将其进行删除，实现代码如下：

```ts
// index.ts
request<T>(config: RequestConfig): Promise<T> {
  return new Promise((resolve, reject) => {
    // 如果我们为单个请求设置拦截器，这里使用单个请求的拦截器
    if (config.interceptors?.requestInterceptors) {
      config = config.interceptors.requestInterceptors(config)
    }
    const url = config.url
    // url存在保存取消请求方法和当前请求url
    if (url) {
      this.requestUrlList?.push(url)
      config.cancelToken = new axios.CancelToken(c => {
        this.cancelRequestSourceList?.push({
          [url]: c,
        })
      })
    }
    this.instance
      .request<any, T>(config)
      .then(res => {
        // 如果我们为单个响应设置拦截器，这里使用单个响应的拦截器
        if (config.interceptors?.responseInterceptors) {
          res = config.interceptors.responseInterceptors<T>(res)
        }

        resolve(res)
      })
      .catch((err: any) => {
        reject(err)
      })
      .finally(() => {
        url && this.delUrl(url)
      })
  })
}
```

这里我们将删除操作进行了抽离，将其封装为一个私有方法，示例代码如下：

```ts
// index.ts
/**
 * @description: 获取指定 url 在 cancelRequestSourceList 中的索引
 * @param {string} url
 * @returns {number} 索引位置
 */
private getSourceIndex(url: string): number {
  return this.cancelRequestSourceList?.findIndex(
    (item: CancelRequestSource) => {
      return Object.keys(item)[0] === url
    },
  ) as number
}
/**
 * @description: 删除 requestUrlList 和 cancelRequestSourceList
 * @param {string} url
 * @returns {*}
 */
private delUrl(url: string) {
  const urlIndex = this.requestUrlList?.findIndex(u => u === url)
  const sourceIndex = this.getSourceIndex(url)
  // 删除url和cancel方法
  urlIndex !== -1 && this.requestUrlList?.splice(urlIndex as number, 1)
  sourceIndex !== -1 && this.cancelRequestSourceList?.splice(sourceIndex as number, 1)
}
```

- 取消请求方法

现在我们就可以封装取消请求和取消全部请求了，我们先来封装一下取消全部请求吧，这个比较简单，只需要调用`this.cancelRequestSourceList`中的所有方法即可，实现代码如下：

```ts
// index.ts
// 取消全部请求
cancelAllRequest() {
  this.cancelRequestSourceList?.forEach(source => {
    const key = Object.keys(source)[0]
    source[key]()
  })
}
```

现在我们封装一下取消请求，因为它可以取消一个和多个，那它的参数就是`url`，或者包含多个URL的数组，然后根据传值的不同去执行不同的操作，实现代码如下：

```ts
// index.ts
// 取消请求
cancelRequest(url: string | string[]) {
  if (typeof url === 'string') {
    // 取消单个请求
    const sourceIndex = this.getSourceIndex(url)
    sourceIndex >= 0 && this.cancelRequestSourceList?.[sourceIndex][url]()
  } else {
    // 存在多个需要取消请求的地址
    url.forEach(u => {
      const sourceIndex = this.getSourceIndex(u)
      sourceIndex >= 0 && this.cancelRequestSourceList?.[sourceIndex][u]()
    })
  }
}
```

- 测试请求方法

现在我们就来测试一下这个请求方法，这里我们使用**www.apishop.net/**[3]提供的免费API进行测试，测试代码如下：

```ts
<script setup lang="ts">
// app.vue
import request from './service'
import { onMounted } from 'vue'

interface Req {
  apiKey: string
  area?: string
  areaID?: string
}
interface Res {
  area: string
  areaCode: string
  areaid: string
  dayList: any[]
}
const get15DaysWeatherByArea = (data: Req) => {
  return request<Req, Res>({
    url: '/api/common/weather/get15DaysWeatherByArea',
    method: 'GET',
    data,
    interceptors: {
      requestInterceptors(res) {
        console.log('接口请求拦截')

        return res
      },
      responseInterceptors(result) {
        console.log('接口响应拦截')
        return result
      },
    },
  })
}
onMounted(async () => {
  const res = await get15DaysWeatherByArea({
    apiKey: import.meta.env.VITE_APP_KEY,
    area: '北京市',
  })
  console.log(res.result.dayList)
})
</script>
```

如果在实际开发中可以将这些代码分别抽离。

上面的代码在命令中输出

```ts
接口请求拦截
实例请求拦截器
全局请求拦截器
实例响应拦截器
全局响应拦截器
接口响应拦截
[{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
```

- 测试取消请求

首先我们在`.server/index.ts`中对取消请求方法进行导出，实现代码如下：

```ts
// 取消请求
export const cancelRequest = (url: string | string[]) => {
  return request.cancelRequest(url)
}
// 取消全部请求
export const cancelAllRequest = () => {
  return request.cancelAllRequest()
}
```

然后我们在`app.vue`中对其进行引用，实现代码如下：

```vue
<template>
  <el-button
    @click="cancelRequest('/api/common/weather/get15DaysWeatherByArea')"
    >取消请求</el-button
  >
  <el-button @click="cancelAllRequest">取消全部请求</el-button>
  <router-view></router-view>
</template>
<script setup lang="ts">
import request, { cancelRequest, cancelAllRequest } from './service'
</script>
```

